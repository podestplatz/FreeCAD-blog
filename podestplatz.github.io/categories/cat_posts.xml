<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FreeCAD BCF-Plugin development blog (Posts about posts)</title><link>https://podestplatz.github.io/FreeCAD-blog/</link><description></description><atom:link href="https://podestplatz.github.io/FreeCAD-blog/categories/cat_posts.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2019 &lt;a href="mailto:podestplatz@gmail.com"&gt;Patrick Podest&lt;/a&gt; </copyright><lastBuildDate>Thu, 13 Jun 2019 16:20:53 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Writing non Schema Conform BCF Files</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/writing-non-schema-conform-bcf-files/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;Wait would you write files with the intention that they don't conform to the
provided XSD files? ... you might ask by just reading the title. No I wouldn't.
As I introduced in my last blog post (&lt;a class="reference external" href="https://podestplatz.github.io/FreeCAD-blog/posts/handling-non-conform-bcf-files/"&gt;Handling Non-Conform BCF Files&lt;/a&gt;), that
was not an update of the dev-logs post, I introduced the need of supporting
files from vendors that might do some things differently. I ended this last post
with a pros and cons list about two approaches that I thought of. In the
meantime I decided for latter one.&lt;/p&gt;
&lt;div class="section" id="recap"&gt;
&lt;h2&gt;Recap&lt;/h2&gt;
&lt;p&gt;The second approach, let's call it update approach, extracts the BCF file to a
temporary folder, reads the contents into memory (that are conform to the
corresponding XSD file) and every time the state in
memory is changed the updates get written to the dicrectory structure in the
temporary folder. At the end, when the plugin is closed and its lifetime ends,
this directory is compressed again and stored in its original location. The
update approach thereby does not alter any data that the plugin didn't load into
memory, it works "around" it.&lt;/p&gt;
&lt;p&gt;I think this is the better appraoch, since no exceptions to the rule have to be
made for every speciality that a vendor might incorporate in its files. However,
the writer module has to have an understanding of XML baked in, in order for it
to be able to update these files in place.&lt;/p&gt;
&lt;p&gt;In the next section I want to elaborate a bit more on how I envision this writer
module.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-actual-stuff"&gt;
&lt;h2&gt;Writing actual stuff&lt;/h2&gt;
&lt;p&gt;At the beginning of every writing operation it has to be known whether an
existing element shall be modified, a new element shall be added or an existing
one shall be deleted. Following you will find my thoughts, uncompiled, as I have
written them down onto paper. First will be the handling of additions.&lt;/p&gt;
&lt;hr class="docutils"&gt;
&lt;div class="section" id="how-can-additions-be-handled"&gt;
&lt;h3&gt;How can additions be handled?&lt;/h3&gt;
&lt;p&gt;Every element class (a class that directly represents a XML-Element like
&lt;cite&gt;Comment&lt;/cite&gt;) shall have a function that returns the XML-Text. This text is then
going to be inserted at the right place by the writer module.
The writer module has to crawl through the complete data model to check/compile
a list of objects that were added, changed or deleted. Then for each added
object it calls the XML-Text function to get the corresponding XML-text for each
element. A second function shall give the following information about the
position at which it should be inserted (could also be done with a dictionary,
that way the data model stays clean):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;the containing element: the containing element of &lt;cite&gt;Comment&lt;/cite&gt; is &lt;cite&gt;Markup&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;the relatie order: a list of elements that preceed the current one in
reverse order. So the immediate predecessor is first in the list. The last
element of the list is the containing element.&lt;/li&gt;
&lt;li&gt;if the new element shall be added inside an element that might occur more than
once (e.g.: &lt;cite&gt;ModifiedDate&lt;/cite&gt; in &lt;cite&gt;Comment&lt;/cite&gt;) then also a unique id of that list
element has to be retrieved.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The writer then searches for the containing element in the file and then goes
through the contents of the containing element, searching for the one with the
least index in the relative order list. The text is inserted right after the
closing tag of the chosen element.&lt;/p&gt;
&lt;p&gt;Any references should not be handled/checked in the writer module (e.g.: that
the viewpoint guid in the to be written comment object belongs to an actual
existing viewpoint). Such consistency checks are assumed to be handled in the
GUI or the programmatic interface respectively.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils"&gt;
&lt;div class="section" id="how-can-updates-be-handled"&gt;
&lt;h3&gt;How can updates be handled?&lt;/h3&gt;
&lt;p&gt;An element either has to occur only once in the corresponding file, or be
identified uniquely by some attribute. Without one of these two constraints the
identification of the right element in the XML-file becomes extremely hard or
cannot be done deterministically.
An object shall be flagged &lt;cite&gt;MODIFIED&lt;/cite&gt; iff (=if and only if) a non-list child
element was changed. A change of a list element translates either to an addition
or deletion, or a change of an element that can be identified
deterministically, as described above. In which case the object, containing the
list with one or more items changed, shall not be flagged &lt;cite&gt;MODIFIED&lt;/cite&gt;. Each
object shall then contain a list of changed objects, oblivious of whether it
translates to an attribute or element. for each of these objects the writer
module has to gather following information:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;element hierarchy: &lt;cite&gt;ModifiedDate&lt;/cite&gt; in &lt;cite&gt;Comment&lt;/cite&gt; would have
&lt;cite&gt;ModifiedDate&lt;/cite&gt; -&amp;gt; &lt;cite&gt;Comment&lt;/cite&gt; -&amp;gt; &lt;cite&gt;Markup&lt;/cite&gt; as hierarchy list.&lt;/li&gt;
&lt;li&gt;unique id of every list element that is in the hierarchy (like with additions)&lt;/li&gt;
&lt;li&gt;whether it translates to an attribute or an element&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The writing module shall collect a list of all elements that are flagged
&lt;cite&gt;MODIFIED&lt;/cite&gt;. For each element the writer module shall collect the amount
information listed above. It then follows the element hierarchy of the object in
reverse order till it reaches the changed object itself. At this point the
distinction between attribute and element has to be made. For both cases the
following two steps happen:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;the respective substring of the element has to be found and&lt;/li&gt;
&lt;li&gt;be replaced entirely by the XML-text generated from the object&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;hr class="docutils"&gt;
&lt;div class="section" id="how-can-deletions-be-handled"&gt;
&lt;h3&gt;How can deletions be handled?&lt;/h3&gt;
&lt;p&gt;The writer module compiles a list of all elements to delete. For each element
the following information shall be gathered:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;which file is the element contained in&lt;/li&gt;
&lt;li&gt;unique id of the element (if available)&lt;/li&gt;
&lt;li&gt;name of the element&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The writer module then searches for the unique id in the specified file that
also matches the element name and deletes it from the start to the end tag.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils"&gt;
&lt;div class="section" id="how-shall-the-interface-to-the-writer-look"&gt;
&lt;h2&gt;How shall the interface to the writer look?&lt;/h2&gt;
&lt;p&gt;The above mentioned crawler has the advantage of alos supporting writing the
file only once. Therefore also being somewhat resource saving.
The writer shall have a function &lt;cite&gt;writeChanges()&lt;/cite&gt;. This function receives an
object of type &lt;cite&gt;project&lt;/cite&gt; which denotes the starting point of the search. Every
object shall have a variable of enum type. This variable is allowed to take on
one of the following four values:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ORIGINAL&lt;/li&gt;
&lt;li&gt;MODIFIED&lt;/li&gt;
&lt;li&gt;ADDED&lt;/li&gt;
&lt;li&gt;DELETED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each of these states the writer maintains a separate list. Each state has to
be handled differenty during writing. It shall also be possible for the user to
just issue an update of all of these four lists and then subsequently manually
decides the point in time when updates shall be written.
=&amp;gt; &lt;cite&gt;updatechangdLists()&lt;/cite&gt; -&amp;gt; &lt;cite&gt;writeChanges()&lt;/cite&gt;. Since &lt;cite&gt;writeChanges()&lt;/cite&gt; now has to
fulfill two functions: once triggering &lt;cite&gt;updateChangedLists()&lt;/cite&gt; and the other time
just take these lists as they are, its argument shall be optional.
For an addition, deletion, update it is important to know in which folder the
to-update file is stored. For this a get topic function shall be implemented.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>bcf schema</category><guid>https://podestplatz.github.io/FreeCAD-blog/posts/writing-non-schema-conform-bcf-files/</guid><pubDate>Fri, 07 Jun 2019 16:02:56 GMT</pubDate></item><item><title>Handling Non-Conform BCF Files</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/handling-non-conform-bcf-files/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;This post shall just collect some ideas I had about handling BCF files whose
contents may not be (in part) conform to the &lt;a class="reference external" href="https://github.com/buildingSMART/BCF-XML/tree/master/Schemas"&gt;XSDs&lt;/a&gt; supplied by buildingSmart on
github.&lt;/p&gt;
&lt;div class="section" id="why-is-there-a-need-for-that"&gt;
&lt;h2&gt;Why is there a need for that?&lt;/h2&gt;
&lt;p&gt;Well, during testing with one of the two BCF files I currently have (here the
&lt;a class="reference external" href="https://www.bimcollab.com/Files/Example-Projects/BIMcollab_Example_project_Issues-bcfzip.aspx"&gt;link to the first one&lt;/a&gt; to download) I wanted to validate each file I read in,
before I read it in, to be (mostly) sure that my code does not throw unexpected
exceptions. But already in &lt;cite&gt;markup.bcf&lt;/cite&gt; of the first topic the library I use,
&lt;a class="reference external" href="https://pypi.org/project/xmlschema/"&gt;xmlschema&lt;/a&gt;, threw an &lt;cite&gt;XMLSchemaValidatorError&lt;/cite&gt;. The reason was that the node
&lt;cite&gt;&amp;lt;Header /&amp;gt;&lt;/cite&gt; was defined, but it was defined empty, which is prohibited by
&lt;a class="reference external" href="https://github.com/buildingSMART/BCF-XML/blob/master/Schemas/markup.xsd"&gt;markup.xsd&lt;/a&gt;. So as quick fix I deleted the &lt;cite&gt;&amp;lt;Header /&amp;gt;&lt;/cite&gt; node altogether to be
able to test my code somewhat. But now on to the next section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-does-xmlschema-report-parsing-errors"&gt;
&lt;h2&gt;How does &lt;cite&gt;xmlschema&lt;/cite&gt; report parsing errors?&lt;/h2&gt;
&lt;p&gt;Before we can go into the problem solution, a little investigation of the
library I am using has to be done. We need to know how it handles the nodes and
attributes that could not be parsed/decoded against the corresponding XSD
file.
For parsing/decoding &lt;a class="reference external" href="https://pypi.org/project/xmlschema/"&gt;xmlschema&lt;/a&gt; defines the following three &lt;a class="reference external" href="https://xmlschema.readthedocs.io/en/latest/usage.html#xsd-validation-modes"&gt;validation
modes&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;strict&lt;/strong&gt;: Schemas are validated against the meta-schema. The processor stops
when an error is found in a schema or during the validation/decode of XML
data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lax&lt;/strong&gt;: Schemas are validated against the meta-schema. The processor collects
the errors and continues, eventually replacing missing parts with wildcards.
Undecodable XML data are replaced with None.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;skip&lt;/strong&gt;: Schemas are not validated against the meta-schema. The processor
doesn't collect any error. Undecodable XML data are replaced with the original
text.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For the ones, like me, that got confused by the first sentence of the first two modes:
every schema that is read in is itself validated against a schema, the
meta-schema, before it can be used. These modes can be used separately for
reading the schema file and for parsing/decoding a XML file. So for example it
is possible to read the &lt;cite&gt;markup.xsd&lt;/cite&gt; in &lt;strong&gt;strict&lt;/strong&gt; mode, thereby validating it
against a meta-schema, but then parsing/decoding the &lt;cite&gt;markup.bcf&lt;/cite&gt; file in
&lt;strong&gt;lax&lt;/strong&gt; or &lt;strong&gt;skip&lt;/strong&gt; mode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="in-what-way-can-errors-be-handled"&gt;
&lt;h2&gt;In what way can errors be handled?&lt;/h2&gt;
&lt;p&gt;Given the modes in which XML files can be read in by &lt;a class="reference external" href="https://pypi.org/project/xmlschema/"&gt;xmlschema&lt;/a&gt; I could only
think about the following two possibilities on how to handle possible errors:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Just ignore the node that could not be parsed/decoded against the
corresponding schema file. Easy to accomplish with &lt;strong&gt;lax&lt;/strong&gt; mode.&lt;/li&gt;
&lt;li&gt;Read in the plain XML text for that node, store it somewhere in the data
structure and when writing it all out again just insert the plain XML text into
the right place. Only possible in &lt;strong&gt;skip&lt;/strong&gt; mode.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The main drawback of number 1 is clearly that the data, that couldn't be read
in, would be lost, or only exist in an earlier version of the BCF file, after
the datastructure got written. It would certainly be easy to implement but does
not offer the user great value if his or her data get lost. This is, however, on
the premise of reading in the file once and writing it once after all changes
have been made in memory.&lt;/p&gt;
&lt;p&gt;The second option offers a possibility to circumvent the lost data problem. The
not-parsable elements just get read in plain.&lt;/p&gt;
&lt;p&gt;But there may be another option that could use &lt;strong&gt;lax&lt;/strong&gt; mode without the data
loss. This option is another approach to writing the contents of the
datastructure to the file. Originally I planned to do it in one sweep when the
user presses the enter key or the save button for that matter.  But then
&lt;a class="reference external" href="https://forum.freecadweb.org/memberlist.php?mode=viewprofile&amp;amp;u=255"&gt;hardeeprai&lt;/a&gt; from the &lt;a class="reference external" href="https://forum.freecadweb.org/"&gt;freecad forum&lt;/a&gt; suggested, to another topic, that I
write changes right after the were made. So effectively implementing an update
driven approach to making changes permanent.&lt;/p&gt;
&lt;p&gt;So now there are two possible approaches to handling errors that each use a
different validation mode. In the next section I want to list some thoughts I
came up with for each one of these approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="approaches-pros-cons"&gt;
&lt;h2&gt;Approaches: Pros &amp;amp; Cons&lt;/h2&gt;
&lt;div class="section" id="reading-once-and-writing-once"&gt;
&lt;h3&gt;Reading once and writing once&lt;/h3&gt;
&lt;p&gt;As already established, &lt;strong&gt;skip&lt;/strong&gt; mode must be used here with &lt;cite&gt;xmlschema&lt;/cite&gt;. For
every member in the data structure it has to be noted somewhere if it could be
read in or not. That would indicate whether the node holds the acutal value of
the intended datatype or if it holds the plain XML text as string.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage:&lt;/strong&gt; writing the datastructure is fairly easy&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage #1:&lt;/strong&gt; every class, that represents part of the XML file, has to be
changed in order to house the additional information about every member or a
whole new datastructure has to be created for that.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage #2:&lt;/strong&gt; the type annotations become invalid, if this approach is
used, which leads to confusion by the ones reading the code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage #3:&lt;/strong&gt; the module that reads in the XML file into the data model
becomes much more complex, thereby not aiding the understandability of the code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="updating-the-file-on-the-fly"&gt;
&lt;h3&gt;Updating the file on the fly&lt;/h3&gt;
&lt;p&gt;Here &lt;strong&gt;lax&lt;/strong&gt; mode can be used with &lt;cite&gt;xmlschema&lt;/cite&gt;. Still the whole file has to be
read in once, but the parts that could not be parsed/decoded stay in the file and are
not read in. To really be able to update the original file, the datamodel has to
accommodate information for every element if it is new or updated, and therefore
shall be written or not. The overhead here is comparable to the first approach
but every class just needs one additional member to signify a change or that
this object was newly created.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage #1:&lt;/strong&gt; (as already mentioned) not so much overhead in the data model
compared to the first approach.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage #2:&lt;/strong&gt; The user is not exposed to the danger of losing unsaved
changes, since it is updated every time a new change is committed to the data
representation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage #1:&lt;/strong&gt; the module that writes the data to the BCF file has to have
light parsing capabilities or a XML awareness respectively, in order to be able
to edit XML files directly. This does not have to be the case with the first
approach, since we could utilize the &lt;cite&gt;xmlschema&lt;/cite&gt; library.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage #2:&lt;/strong&gt; Objects that get deleted must not be deleted right away
from the data model. Rather a flag has to be set that it is "deleted" and the
corresponding part in the file has to be removed as well. After that it can be
removed from the data model.&lt;/p&gt;
&lt;hr class="docutils"&gt;
&lt;p&gt;I am gravitating more to the latter option, since it does not interfere with the
type annotations, and therefore does not complicate the whole type situation
in the data model. What I still have to face, however, is the XML aware writer
module. This is going to be fun!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>bcf</category><category>schema</category><category>xml</category><guid>https://podestplatz.github.io/FreeCAD-blog/posts/handling-non-conform-bcf-files/</guid><pubDate>Sat, 01 Jun 2019 07:50:16 GMT</pubDate></item><item><title>Schema Constraints Revisited</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/schema-constraints-revisited/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;In an &lt;a class="reference external" href="https://podestplatz.github.io/FreeCAD-blog/posts/how-to-represent-extensionxsd-constraints/"&gt;older post&lt;/a&gt;, one or two weeks back, I've written about a design issue I was
facing when trying to integrate the constraints of &lt;a class="reference external" href="https://github.com/buildingSMART/BCF-XML/blob/release_2_1/Extension%20Schemas/extensions.xsd"&gt;extensions.xsd&lt;/a&gt; into my
class model. &lt;cite&gt;extension.xsd&lt;/cite&gt; defines possible values for the XML nodes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;TopicType&lt;/li&gt;
&lt;li&gt;TopicLabel&lt;/li&gt;
&lt;li&gt;TopicStatus&lt;/li&gt;
&lt;li&gt;SnippetType&lt;/li&gt;
&lt;li&gt;Priority&lt;/li&gt;
&lt;li&gt;Stage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I wanted to ensure that the variables, representing let's say &lt;cite&gt;TopicType&lt;/cite&gt;, can
only assume valid values, as defined in &lt;cite&gt;extension.xsd&lt;/cite&gt;.  My first idea was to
just define &lt;a class="reference external" href="https://docs.python.org/3/library/enum.html"&gt;Enums&lt;/a&gt; following the schema. Generally this idea is fine but it
doesn't do so well with version changes. A new version of the BCF-XML standard
would then possibly require more maintenance work than necessary. My aim with
this &lt;a class="reference external" href="https://github.com/podestplatz/BCF-Plugin-FreeCAD"&gt;BCF plugin for FreeCAD&lt;/a&gt; is it to create a data model that requires as
little maintenance work as possible, although the code still has to be adapted
to support any new version.&lt;/p&gt;
&lt;p&gt;From the maintenance point of view hardcoded enumerations were not really an option.&lt;/p&gt;
&lt;p&gt;The next idea was to create something like dynamic enumerations. These would
have the advantage that the constraint is enforced (i.e.: a variable holding an
enumeration value can only hold a valid value as defined in the enumeration
itself). I knew it was possible to change a class object (not the object &lt;em&gt;of&lt;/em&gt; a
class) during runtime and add or remove members from it.  I thought maybe this
is also possible with classes that derive from &lt;cite&gt;Enum&lt;/cite&gt;. In python to create an
enumeration you just have to define a class like this:&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;enum&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Enum&lt;/span&gt;
&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-2"&gt;&lt;/a&gt;
&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Example&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-4"&gt;&lt;/a&gt;  &lt;span class="n"&gt;VAL1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-5"&gt;&lt;/a&gt;  &lt;span class="n"&gt;VAL2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;a name="rest_code_28961d1f373348e78c69c7d9b79bcb1e-6"&gt;&lt;/a&gt;  &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The first obstacle was that classes can only derive from a class (that itself
derives from &lt;cite&gt;Enum&lt;/cite&gt;) iff they don't introduce new members. Otherwise this would
break some invariants the python interpreter has over enumerations.
The second obstacle was a logical implication of the first: if subclasses
couldn't add new members to an enum-super-class then it is also not possible to
add new members to enumerations during runtime.&lt;/p&gt;
&lt;p&gt;So another solution had to be thought of. I maintained the basic structure I
had envisioned for the dynamic enumeration solution. Namely one superclass
called &lt;cite&gt;SchemaConstraint&lt;/cite&gt; and one subclass for each of the above mentioned XML
nodes. Every piece of code that wants to represent one of these XML nodes would
store an object of one of the subclasses in a variable of type &lt;cite&gt;SchemaConstraint&lt;/cite&gt;.
The actual value of the object is stored in a class variable, &lt;cite&gt;value&lt;/cite&gt;, that
holds just any value of type string. This approach of course has the downside that
basically any value can be assigned to the variable &lt;cite&gt;value&lt;/cite&gt;, if not restricted.
In order to change this I made the class variable &lt;cite&gt;value&lt;/cite&gt; a property where the
setter checks whether the new value is actually a valid value.&lt;/p&gt;
&lt;p&gt;Now the question arises: How does the setter function know which value is valid?
Every node has different valid values!&lt;/p&gt;
&lt;p&gt;To solve this issue I introduced, for one, the list &lt;cite&gt;validValues&lt;/cite&gt; into
&lt;cite&gt;SchemaConstraints&lt;/cite&gt; (&lt;cite&gt;value&lt;/cite&gt; does also reside there) and, for the other, a
static function called &lt;cite&gt;parseConstraints(elementName)&lt;/cite&gt;. This static function
reads the valid values for the XML node &lt;cite&gt;elementName&lt;/cite&gt; from &lt;cite&gt;extension.xsd&lt;/cite&gt; and
returns them as list.  &lt;cite&gt;parseConstraints()&lt;/cite&gt; is intended to be called from the
&lt;cite&gt;__init__()&lt;/cite&gt; function of each one of the sub classes (e.g.:
&lt;cite&gt;TopicType.__init__()&lt;/cite&gt;). To make things clearer I put a small code example below
showing the classes &lt;cite&gt;SchemaConstraints&lt;/cite&gt; and &lt;cite&gt;TopicType&lt;/cite&gt; as well as all the
members of both classes.&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SchemaConstraint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-2"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;validValues&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-3"&gt;&lt;/a&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-4"&gt;&lt;/a&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;validValues&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;validValues&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-5"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-6"&gt;&lt;/a&gt;  &lt;span class="nd"&gt;@property&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-7"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-8"&gt;&lt;/a&gt;    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-10"&gt;&lt;/a&gt;  &lt;span class="nd"&gt;@value.setter&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-11"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-12"&gt;&lt;/a&gt;    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-13"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-14"&gt;&lt;/a&gt;  &lt;span class="nd"&gt;@property&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-15"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;validValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-16"&gt;&lt;/a&gt;    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-17"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-18"&gt;&lt;/a&gt;  &lt;span class="nd"&gt;@validValues.setter&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-19"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;validValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-20"&gt;&lt;/a&gt;    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-21"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-22"&gt;&lt;/a&gt;  &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-23"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parseConstraints&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elementName&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-24"&gt;&lt;/a&gt;    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-25"&gt;&lt;/a&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-26"&gt;&lt;/a&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TopicType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SchemaConstraint&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-27"&gt;&lt;/a&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-28"&gt;&lt;/a&gt;    &lt;span class="n"&gt;validValues&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SchemaConstraint&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parseConstraints&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"TopicType"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_09f9cd8c2a80497fb235fead45ccf328-29"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TopicType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;validValues&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;validValues&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;One important thing to note here is that the setter method of &lt;cite&gt;validValues&lt;/cite&gt; has
just one line which contains &lt;cite&gt;pass&lt;/cite&gt;. This is done in order to ensure that the
set of valid values does not get overwritten, at least not that easily.&lt;/p&gt;
&lt;p&gt;This solution has, for one, the advantage of being adaptable, in case new values
get added to the list of valid values and, for the other, through the setter function of &lt;cite&gt;value&lt;/cite&gt;
it can be enforced that the state of an object is always valid.&lt;/p&gt;&lt;/div&gt;</description><guid>https://podestplatz.github.io/FreeCAD-blog/posts/schema-constraints-revisited/</guid><pubDate>Tue, 28 May 2019 13:18:31 GMT</pubDate></item><item><title>Learning XSD Syntax</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/learning-xsd-syntax/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;The main takeaway from the XML Schema Definition Tutorial I went through today
was the following:&lt;/p&gt;
&lt;blockquote&gt;
So the node &lt;cite&gt;&amp;lt;xs:sequence&amp;gt;...&amp;lt;/xs:sequence&amp;gt;&lt;/cite&gt; is part of the definition of a
complex type, it is also called an indicator. What it does is that it tells the
XML checker that the elements specified inside have to occur in the same order
in the XML document to be valid. Also it specifies what elements may be
contained in the complex node.&lt;/blockquote&gt;
&lt;p&gt;This greatly improved my understanding of &lt;cite&gt;visinfo.xsd&lt;/cite&gt; which describes how a
&lt;cite&gt;viewpoint.bcfv&lt;/cite&gt; file is built. As I learned during design, the representation
of a viewpoint is almost as complex as the representation of the remaining
contents of a BCF file.&lt;/p&gt;
&lt;p&gt;I thought about how I coudl read the contents of a BCF into this file structure.
As my brain always does, it thinks through the whole process, from checking if
the given file is valid till the point where all the data resides in an object
in memory. This makes me prone to "reinventing the wheel" as I also design a XSD
parser/checker in my head which I then would use to check the given files before
reading them in. But a quick google search brought up a better option, namely an
offical &lt;a class="reference external" href="https://pypi.org/project/xmlschema/"&gt;python library&lt;/a&gt; for checking XML files against a schema.&lt;/p&gt;
&lt;p&gt;Last but not least: I am pleased to announce that the first draft of the class
diagram is ready. You can find it &lt;a class="reference external" href="https://github.com/podestplatz/BCF-Plugin-FreeCAD/tree/master/doc"&gt;here&lt;/a&gt; if you are interested.&lt;/p&gt;&lt;/div&gt;</description><category>bcf</category><category>bim</category><category>class-diagram</category><category>GSoC</category><guid>https://podestplatz.github.io/FreeCAD-blog/posts/learning-xsd-syntax/</guid><pubDate>Wed, 15 May 2019 04:24:35 GMT</pubDate></item><item><title>Advancing to the Viewpoint.bcf part</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/finishing-up-the-datamodel-uml/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;In the &lt;a class="reference external" href="https://forum.freecadweb.org/viewtopic.php?p=308095#p308095"&gt;forum post&lt;/a&gt; yesterday, Yorik pointed out that, although part of the
specification, the BimSnippet does not have to be treated with high priority. He
also referred me to Bernd and Duncan in case of questions arising.
As advised, I will consider the BimSnippet in the data model but probably won't
implement it right away.&lt;/p&gt;
&lt;p&gt;The progress I made today was mostly in understanding the BCF specification in
regards to the viewpoint.bcfv file. Multiple viewpoint files can be contained
within the folder of one topic. At the beginning of the day I thought that the
data model would be finished rather quick but as it turned out the documentation
on it is not as concise as one might wish it to be. To be more precise: the
whole section about the "Components" element is a bit confusing. It lists
multiple "properties", like &lt;cite&gt;Selection&lt;/cite&gt; and &lt;cite&gt;Visibility&lt;/cite&gt;. My intuition says that
&lt;cite&gt;Selection&lt;/cite&gt; contains a list of components that are selected, and &lt;cite&gt;Visibility&lt;/cite&gt;
specifies whether these components shall be visible or not. But in reality each
contains a list of components onto which the values of the attributes of the
respective property shall be applied.&lt;/p&gt;
&lt;p&gt;This is a bit confusing at first, and still is for me. Because of this ambiguity
I decided, for the further data model design, that refer to the related XML
schemas rather than the written documentation. For example here you can find the
schema for the &lt;a class="reference external" href="https://github.com/buildingSMART/BCF-XML/blob/master/Schemas/visinfo.xsd"&gt;viewpoint.bcf&lt;/a&gt; file.&lt;/p&gt;
&lt;p&gt;But since the last time I have worked with XML schemas was in vocational school
(I think 2012) I have to refresh my memory on it. For that I will go through the
relevant parts of the &lt;a class="reference external" href="https://www.w3schools.com/xml/schema_intro.asp"&gt;W3CSchools: XML Schema Tutorial&lt;/a&gt;. Tomorrow.&lt;/p&gt;&lt;/div&gt;</description><category>bcf</category><category>bim</category><category>class-diagram</category><category>GSoC</category><guid>https://podestplatz.github.io/FreeCAD-blog/posts/finishing-up-the-datamodel-uml/</guid><pubDate>Tue, 14 May 2019 03:42:30 GMT</pubDate></item><item><title>Representing markup.bcf in UML</title><link>https://podestplatz.github.io/FreeCAD-blog/posts/representing-markupbcf-in-uml/</link><dc:creator>Patrick Podest</dc:creator><description>&lt;div&gt;&lt;p&gt;Today I mostly finished the UML class diagram in regard to representing the data
of the &lt;tt class="docutils literal"&gt;markup.bcf&lt;/tt&gt; file. One think I found kind of interesing while creating
the diagram is that in the &lt;a class="reference external" href="https://github.com/BuildingSMART/BCF-XML/tree/master/Documentation"&gt;BCF-XML-Documentation&lt;/a&gt; There is no link between a
topic and a comment, so no id of one is stored in the other. That didn't make
sense at first because I thought that one &lt;tt class="docutils literal"&gt;markup&lt;/tt&gt; could have multiple topics,
which is &lt;strong&gt;not&lt;/strong&gt; the case.&lt;/p&gt;
&lt;p&gt;However one think what is not that obvious to me is the case with the &lt;tt class="docutils literal"&gt;BIMSnippet&lt;/tt&gt;.
On the documentation page it says that: "BimSnippet is an additional file containing
information related to one or multiple topics.". This would imply that there
would be more topics inside one &lt;tt class="docutils literal"&gt;markup.bcf&lt;/tt&gt; file, because &lt;tt class="docutils literal"&gt;BimSnippet&lt;/tt&gt; is,
as I understand, also just a node inside &lt;tt class="docutils literal"&gt;markup.bcf&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Regarding the open question from the previous post: How to represent constraints
defined in &lt;tt class="docutils literal"&gt;extensions.xsd&lt;/tt&gt;; I thought about it a little today and came to the
conclusion that it would be the best approach to go with the last option I
listed. That means that for every node, for which constraints are listed in
&lt;tt class="docutils literal"&gt;extensions.xsd&lt;/tt&gt;, an empty enumeration/class is created which then, during
runtime, gets populated with the valid values.&lt;/p&gt;
&lt;p&gt;UPDATE (2019-05-13): The inconsistency is resolved. The BimSnippet node just references one
file that does not have to be inside the topic folder.&lt;/p&gt;&lt;/div&gt;</description><category>bcf</category><category>bim</category><category>class-diagram</category><category>GSoC</category><guid>https://podestplatz.github.io/FreeCAD-blog/posts/representing-markupbcf-in-uml/</guid><pubDate>Mon, 13 May 2019 17:43:03 GMT</pubDate></item></channel></rss>